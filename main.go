package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"github.com/anthonynsimon/bild/imgio"
	"github.com/anthonynsimon/bild/transform"
	"image"
	"image/color"
	"image/jpeg"
	"image/png"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

func main() {

	tmpDir, err := ioutil.TempDir("", "page")
	if err != nil {
		log.Fatal(err)
	}
	defer os.RemoveAll(tmpDir)

	port := flag.Int("port", 8080, "What port to host the server on")
	clean := flag.Bool("clean", false, "Clean tmp directories or use temporary artifacts")
	placeholders := flag.Bool("placeholders", false, "Generate image placeholders")
	generatedPath := flag.String("gpath", "_", "Where to put generated files in the destination")
	flag.Parse()

	args := flag.Args()

	if len(args) >= 1 && args[0] == "serve" {

		addr := fmt.Sprintf(":%d", *port)

		src := "."
		if len(args) >= 2 {
			src = args[1]
		}

		po := &processOptions{
			Source:               src,
			Destination:          tmpDir,
			Extension:            ".page",
			AutoGeneratedDir:     *generatedPath,
			UsePlaceholderImages: *placeholders,
		}

		serve(po, addr)
	} else if len(args) >= 3 && args[0] == "build" {

		po := &processOptions{
			Extension:            ".page",
			AutoGeneratedDir:     *generatedPath,
			clean:                *clean,
			UsePlaceholderImages: *placeholders,
			Source:               args[1],
			Destination:          args[2],
		}

		fileInfo, err := os.Stat(po.Source)
		if err != nil {
			panic(err)
		}

		gs := NewGlobalScope()


		if fileInfo.IsDir() {
			if err := processDir(gs, po.Source, po.Destination, po); err != nil {
				panic(err)
			}
		} else {
			if err := processFile(gs, po.Source, po.Destination, po); err != nil {
				panic(err)
			}
		}
	} else {
		log.Println("Usage")
		fmt.Println("Build a project")
		fmt.Printf("%s build src dst\n", os.Args[0])
		fmt.Println("Run a self hosted serve")
		fmt.Printf("%s serve directoryToServe\n", os.Args[0])
	}
}

func processDir(gs *GlobalScope, src, dst string, po *processOptions) error {

	items, _ := ioutil.ReadDir(src)
	for _, item := range items {
		// skip hidden files
		n := item.Name()
		if strings.HasPrefix(n, ".") {
			continue
		}

		s, d := filepath.Join(src, n), filepath.Join(dst, n)
		if item.IsDir() {
			if err := processDir(gs, s, d, po); err != nil {
				return err
			}
		} else {
			ext := filepath.Ext(n)
			if ext == po.Extension  {
				if filepath.Base(n)[0] != '_' {
					d := filepath.Join(dst, n[0:len(n)-len(po.Extension)]+".html")
					if err := processFile(gs, s, d, po); err != nil {
						return err
					}
				}
			} else {
				if _, err := copyFile(s, d); err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func copyFile(src, dst string) (int64, error) {

	sourceFileStat, err := os.Stat(src)
	if err != nil {
		return 0, err
	}

	if !sourceFileStat.Mode().IsRegular() {
		return 0, fmt.Errorf("%s is not a regular file", src)
	}

	if err := os.MkdirAll(filepath.Dir(dst), os.ModePerm); err != nil {
		return 0, err
	}

	source, err := os.Open(src)
	if err != nil {
		return 0, err
	}
	defer source.Close()

	destination, err := os.Create(dst)
	if err != nil {
		return 0, err
	}
	defer destination.Close()
	nBytes, err := io.Copy(destination, source)
	return nBytes, err
}




func processFile(gs *GlobalScope, src, dst string, po *processOptions) error {
	log.Println("Processing " + src)
	root, err := parseFile(src)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(filepath.Dir(dst), os.ModePerm); err != nil {
		return err
	}

	nodeState := &Scope{
		tags: make(map[string]*Tag),
		FileScope: &FileScope{Path: src, Options: po, GlobalScope: gs, UniqueClass: &HtmlRenderingBuffer{}},
	}
	out := &bytes.Buffer{}

	if err = formatRoot(nodeState, root, out); err != nil {
		return err
	}

	if err := ioutil.WriteFile(dst, out.Bytes(), 0644); err != nil {
		return err
	}

	return nil
}

func formatRoot(scope *Scope, n *Tag, out *bytes.Buffer) error {
	if n.Type != "*" {
		return errors.New("expecting root tag")
	}

	for _, c := range n.Children {
		if err := format(scope, c, n, out); err != nil {
			return err
		}
	}
	return nil
}

func formatCoreHtml(scope *Scope, n *Tag, out *bytes.Buffer) error {

	//imports := n.GetChildrenWithType("import")
	heads := n.GetChildrenWithType("head")
	bodies := n.GetChildrenWithType("body")

	lang, ok := n.Attributes["lang"]
	if !ok || len(lang) == 0 {
		lang = "en"
	}

	out.WriteString("<!doctype html>\n<html lang=\"" + lang + "\">\n")
	out.WriteString("<head>")

	for _, head := range heads {
		if err := format(scope, head, nil, out); err != nil {
			return err
		}
	}

	out2 := bytes.Buffer{}
	for _, body := range bodies {
		if err := format(scope.CreateChild(), body, nil, &out2); err != nil {
			return err
		}
	}

	if scope.FileScope.UniqueClass.css.Len() > 0 {
		out.WriteString("<style>")
		out.Write(scope.FileScope.UniqueClass.css.Bytes())
		out.WriteString("</style>")
	}
	out.WriteString("</head>")
	out.Write(out2.Bytes())
	out.WriteString("</html>")
	return nil
}

func replaceSubstitutions(v string, attrs map[string]string, consumed map[string]bool) (_ string, err error) {
	if strings.Contains(v, "@") {
		if v, err = parseOut(v, attrs, consumed); err != nil {
			return "", err
		}
	}
	return v, nil
}


func DeepCopy(t *Tag) (dst *Tag, err error) {
	dst = &Tag{
		Type:       t.Type,
		Attributes: make(map[string]string, len(t.Attributes)),
		Children:   make([]*Tag, 0, len(t.Children)),
	}

	for k, v := range t.Attributes {
		dst.Attributes[k] = v
	}

	for _, v := range t.Children {
		cc, err := DeepCopy(v)
		if err != nil {
			return nil, err
		}
		dst.Children = append(dst.Children, cc)
	}

	return dst, nil
}

func DeepCopyAndApplySubstitutions(t *Tag, children []*Tag, attrs map[string]string, consumed map[string]bool, primary bool) (dst *Tag, err error) {

	dst = &Tag{
		Type:       t.Type,
		Attributes: make(map[string]string, len(t.Attributes)),
		Children:   make([]*Tag, 0, len(t.Children)),
	}

	if dst.Text, err = replaceSubstitutions(t.Text, attrs, consumed); err != nil {
		return nil, err
	}

	for k, v := range t.Attributes {
		if v, err = replaceSubstitutions(v, attrs, consumed); err != nil {
			return nil, err
		}
		dst.Attributes[k] = v
	}

	appendChildren := -1
	for _, v := range t.Children {
		if v.Type == "core.children" {
			// Guard against the tag being used twice
			if appendChildren == -1 {
				appendChildren = len(dst.Children)
			}
			continue
		}
		cc, err := DeepCopyAndApplySubstitutions(v, children, attrs, consumed, false)
		if err != nil {
			return nil, err
		}
		dst.Children = append(dst.Children, cc)
	}

	// this appears to be incorrect ... please revise
	if appendChildren != -1 {
		pre := dst.Children[:appendChildren]
		post := dst.Children[appendChildren:]
		dst.Children = []*Tag{}

		dst.Children = append(dst.Children, pre...)
		dst.Children = append(dst.Children, children...)
		dst.Children = append(dst.Children, post...)
	}

	// append any attributes not consumed
	if primary {
		for k, v := range attrs {
			if !consumed[k] {
				dst.Attributes[k] = v
			}
		}
	}
	return dst, nil
}

func parseOut(v string, attrs map[string]string, consumed map[string]bool) (string, error) {

	out := bytes.Buffer{}
	mode := 0
	symbolStart := 0
	for i := 0; i < len(v); i++ {
		c := v[i]
		if mode == 0 {
			if c == '@' {
				mode = 1
			} else {
				out.WriteByte(c)
			}
		} else if mode == 1 {
			if c != '(' {
				return "", errors.New("Invalid syntax: " + v)
			}
			mode = 2
			symbolStart = i + 1
		} else if mode == 2 {
			if c == ')' {
				symbolEnd := i

				symbol := v[symbolStart:symbolEnd]
				if attr, ok := attrs[symbol]; ok {
					out.WriteString(attr)
					consumed[attr] = true
				}
				mode = 0
			}
		}
	}

	if mode != 0 {
		return "", errors.New("Failed to terminate substitution: " + v)
	}

	return out.String(), nil
}

func format(nodeState *Scope, n *Tag, parent *Tag, out *bytes.Buffer) error {

	// skip generating an element
	if v, ok := n.Attributes["ifdef"]; ok && v == "" {
		return nil
	}

	n.Class = nodeState.FileScope.NextClass()

	if template, ok := nodeState.tags[n.Type]; ok {
		consumed := map[string]bool{}
		cp, err := DeepCopyAndApplySubstitutions(template, n.Children, n.Attributes, consumed, true)
		if err != nil {
			return err
		}
		if err := format(nodeState, cp, parent, out); err != nil {
			return err
		}
	} else if n.Type == "core.css" {
		parent.ClassReferenced = true
		if err := formatCss(nodeState, parent.Class, n.Attributes["media"], n.Text, out); err != nil {
			return fmt.Errorf("failed to parse css: %s err: %w", n.Text, err)
		}
	} else if n.Type == "core.include" {

		// TODO disallow specifying prefixes in the names of tags
		// TODO cull down the list of tags, and allow changing of the prefix

		if path, ok := n.Attributes["page"]; !ok {
			return errors.New("Expecting page in core.include tag")
		} else {
			gs := nodeState.GetGlobalScope()

			p := nodeState.FileScope.ResolvePath(path)
			if found := gs.includes[p]; found == nil {
				tag, err := parseFile(p)
				if err != nil {
					return err
				}

				gs.includes[p] = &IncludeFile{
					path: p,
					tags: tag,
				}
			}

			imp := gs.includes[p]

			scope := nodeState.CreateFileChild(imp.path)

			cp, err := DeepCopy(imp.tags)
			if err != nil {
				return err
			}

			// This is a root object so no need to output the actual root
			for _, c := range cp.Children {
				if err := format(scope, c, n, out); err != nil {
					return err
				}
			}

			// copy over any tags from the include
			for k,v := range scope.tags {
				nodeState.tags[k] = v
			}
		}

		return nil
	} else if n.Type == "core.tag" {
		if len(n.Children) == 0 {
			return fmt.Errorf("Tag is empty: %v", n.Attributes["name"])
		} else if strings.Contains(n.Attributes["name"], ".") {
			return fmt.Errorf("Tag name may not contain '.' " + n.Attributes["name"])
		}
		nodeState.tags[n.Attributes["name"]] = n.Children[0]
	} else if n.Type == "comment" {
		// NO output
		return nil
	} else if n.Type == "text" {
		out.WriteString(n.Text)
	} else if n.Type == "head" {
		if err := formatChildren(nodeState, n, out); err != nil {
			return err
		}
	} else if n.Type == "core.html" {
		return formatCoreHtml(nodeState, n, out)
	} else if n.Type == "core.favicon" {
		// look at https://favicon.io/favicon-generator/

		/*
			<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
			<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
			<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
			<link rel="manifest" href="/site.webmanifest">
		*/

	} else {

		tagName := n.Type

		if n.Type == "core.img" {
			tagName = "img"
			if href, ok := n.Attributes["src"]; ok {
				if scale, ok := n.Attributes["resize"]; ok {
					delete(n.Attributes, "resize")

					toks := strings.Split(scale, ",")
					if len(toks) >= 2 {
						ext := filepath.Ext(href)
						w, err0 := strconv.Atoi(toks[0])
						h, err1 := strconv.Atoi(toks[1])
						if err0 != nil || err1 != nil {
							return fmt.Errorf("Invalid image scake w: %d h: %d", toks[0], toks[1])
						}

						if strings.HasPrefix(href, "/") {
							href = href[1:]
						}
						o := nodeState.FileScope.Options
						autoDir := o.AutoGeneratedDir

						dst := filepath.Join(nodeState.FileScope.Options.Destination, autoDir, toks[0], toks[1], href)
						n.Attributes["src"] = fmt.Sprintf("/%s/%d/%d/%s", autoDir, w, h, href)

						if err := os.MkdirAll(filepath.Dir(dst), os.ModePerm); err != nil {
							return err
						}

						var resized *image.RGBA = image.NewRGBA(image.Rect(0, 0, w, h))
						for j := 0; j < h; j++ {
							for i := 0; i < w; i++ {
								resized.SetRGBA(i, j, color.RGBA{R: 127, G: 127, B: 127, A: 255})
							}
						}
						// TODO how to determine if the file already exists
						if ext == ".png" {

							img, err := imgio.Open(filepath.Join(o.Source, href))
							if err == nil {
								resized = transform.Resize(img, w, h, transform.Linear)
							}
							if err := imgio.Save(dst, resized, imgio.PNGEncoder()); err != nil {
								return err
							}
						} else if ext == ".jpg" || ext == ".jpeg" {
							img, err := imgio.Open(filepath.Join(o.Source, href))
							if err == nil {
								resized = transform.Resize(img, w, h, transform.Linear)
							}

							if err := imgio.Save(dst, resized, imgio.JPEGEncoder(90)); err != nil {
								return err
							}
						} else {
							return fmt.Errorf("Only jpeg and png formats are currently supported for scaling")
						}
					}
				}
			}
		}

		out2 := &bytes.Buffer{}
		if err := formatChildren(nodeState, n, out2); err != nil {
			return err
		}

		out.WriteString("\n<" + tagName + " ")

		for k, v := range n.Attributes {
			if k == "class" {
				continue
			} else {
				out.WriteString(fmt.Sprintf(" %v=\"%v\"", k, v))
			}
		}
		// There must only be a single class tag.  Multiple ones will result in unintended consequences
		if n.ClassReferenced {
			out.WriteString(" class=\"" + n.Attributes["class"] + " " + n.Class + "\">")
		} else if v, ok := n.Attributes["class"]; ok {
			out.WriteString(" class=\"" + v + "\">")
		} else {
			out.WriteString(">")
		}

		out.Write(out2.Bytes())
		out.WriteString("</" + n.Type + ">")
	}

	return nil
}

func skipBlock(reader *Reader, out *bytes.Buffer) error {
	if err := reader.Expect('{'); err != nil {
		return err
	}

	out.WriteByte('{')
	for {
		tok, err := reader.PeekByte()
		if err != nil {
			return err
		}

		if tok == '}' {
			break
		}

		if tok == '{' {
			if err = skipBlock(reader, out); err != nil {
				return err
			}
		} else {
			if b, err := reader.ReadByte(); err != nil {
				return err
			} else {
				out.WriteByte(b)
			}
		}
	}

	out.WriteByte('}')
	if err := reader.Expect('}'); err != nil {
		return err
	}

	return nil
}

func GetImageFromFilePath(filePath string) (image.Image, error) {
	f, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	image, _, err := image.Decode(f)
	return image, err
}

func SavePNG(img image.Image, filename string) error {

	if err := os.MkdirAll(filepath.Dir(filename), os.ModePerm); err != nil {
		return err
	}

	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	if err := png.Encode(f, img); err != nil {
		return err
	}
	if err := f.Close(); err != nil {
		return err
	}
	return nil
}

func SaveJpeg(img image.Image, filename string) error {

	if err := os.MkdirAll(filepath.Dir(filename), os.ModePerm); err != nil {
		return err
	}

	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	if err := jpeg.Encode(f, img, nil); err != nil {
		return err
	}
	if err := f.Close(); err != nil {
		return err
	}
	return nil
}

func formatCss(state *Scope, class string, media string, text string, out *bytes.Buffer) error {
	fs := state.FileScope

	encoded := bytes.Buffer{}

	const WaitingForTarget = 0
	const Target = 1

	mode := WaitingForTarget

	reader := Reader{data: []byte(text)}
	for {
		tok, err := reader.PeekByte()
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}

		if tok == '{' {
			if mode == WaitingForTarget {
				encoded.WriteByte('.')
				encoded.WriteString(class)
				encoded.WriteByte(' ')
			}
			if err = skipBlock(&reader, &encoded); err != nil {
				return err
			}
			mode = WaitingForTarget
			continue
		}

		reader.ReadByte()

		if tok == ',' {
			mode = WaitingForTarget
		} else if !isWhitespace(tok) {
			if mode == WaitingForTarget {
				encoded.WriteByte('.')
				encoded.WriteString(class)
				encoded.WriteByte(' ')
				mode = Target
			}
		}

		encoded.WriteByte(tok)
	}

	if media != "" {
		fs.UniqueClass.css.WriteString("@media (" + media + ") {")
	}
	fs.UniqueClass.css.WriteString(encoded.String())
	if media != "" {
		fs.UniqueClass.css.WriteString("}")
	}
	return nil

}

func formatChildren(nodeState *Scope, n *Tag, out *bytes.Buffer) error {
	for _, c := range n.Children {
		if err := format(nodeState, c, n, out); err != nil {
			return err
		}
	}
	return nil
}
